# C++ 中的代码重用

## 包含对象成员的类

> 初始化顺序：和声明的顺序有关。
>
> 各种继承方式：

| 特征 | 公有继承 | 保护继承 | 私有继承 |
| :-: | :-: | :-: | :-: |
| 公有成员变成 | 派生类的公有成员 | 派生类的保护成员 | 派生类的私有成员 |
| 保护成员变成 | 派生类的保护成员 | 派生类的保护成员 | 派生类的私有成员 |
| 私有成员变成 | 只能通过基类接口访问 | 只能通过基类接口访问 | 只能通过基类接口访问 |
| 能否隐式向上转换 | 是 | 是（但只能在派生类中） | 否 |

## 多重继承

> 必须使用关键字 public 来限定每一个基类，否则编译器会**默认私有派生**。

```cpp
class SingingWaiter : public Waiter, public Singer {...};
```

> 虚基类，解决多重继承中的**菱形继承问题**。

## 类模板

```cpp
template <class Type> // or template <typename Type>
class Node {
    ...
    function();
}

Node<Type>::function();
```

### 模板多功能性

1. 递归使用模板

    ```cpp
    ArrayTP< ArrTP<int, 5>, 10 > twodee;
    ```

### 模板的具体化

1. 隐式实例化

    > 在需要对象之前，不会生成类的隐式实例化。

2. 显式实例化

    ```cpp
    template class ArrayTP<string, 100>;
    ```

3. 显式具体化

    ```cpp
    template <typename T>
    class SortedArray {
        ...
    };

    template <> class SortedArray<const char *> {
        ... // 专供 const char * 的模板
    };
    ```

4. 部分具体化

    ```cpp
    template <class T1, class T2> class Paris {...};

    template <class T1> class Paris<T1, int> {...};
    ```

### 将模板用作参数

```cpp
template <template <typename T> class Thing>
class Crab {
    ...
};
```
